/* File generated with Shader Minifier 1.1.6
 * http://www.ctrl-alt-test.fr
 */
#ifndef SHADER_CODE_H_
# define SHADER_CODE_H_

const char *raytrace_comp =
 "#version 430\n"
 "layout(local_size_x=16,local_size_y=16) in;"
 "layout(rgba32f,binding=0)writeonly uniform image2D img_output;"
 "layout(r8ui,binding=1)readonly uniform uimage3D world;\n"
 "#define WS 512\n"
 "#define WH 64\n"
 "#define TR 16\n"
 "#define RD 80.0\n"
 "uniform sampler2D t;struct C{vec3 P;float cY;float cP;float sY;float sP;vec2 fD;};"
 "uniform C c;"
 "uniform vec2 S;"
 "uniform vec3 l,k,a,s;"
 "int f(ivec3 v)"
 "{"
   "return int(imageLoad(world,v).x);"
 "}"
 "bool v(ivec3 v)"
 "{"
   "const vec3 i=step(vec3(0,-2,0),v),R=step(vec3(WS,WH,WS),v);"
   "return dot(i,i)*dot(R,R)==0;"
 "}"
 "vec3 f(in vec3 i,in vec3 R,in float z,in vec3 P,out bool C,out vec3 u,out float T)"
 "{"
   "ivec3 m=ivec3(i),d=ivec3(sign(R));"
   "vec3 e=abs(1/R),y=-fract(i)*d;"
   "y+=max(d,vec3(0));"
   "y*=e;"
   "int W=0;"
   "T=0;"
   "while(T<=z)"
     "{"
       "if(!v(m))"
         "break;"
       "int x=f(m);"
       "if(x!=0)"
         "{"
           "u=i+R*T;"
           "int r=int(mod((u.x+u.z)*TR,TR)),b=int(mod(u.y*TR,TR)+TR);"
           "if(W==1)"
             "{"
               "r=int(mod(u.x*TR,TR));"
               "b=int(mod(u.z*TR,TR));"
               "if(R.y<0.F)"
                 "b+=TR*2;"
             "}"
           "vec3 D=vec3(texture(t,vec2((r+x*TR+.5)/float(TR*16.),(b+.5)/float(TR*3.))));"
           "if(dot(D,D)!=0)"
             "{"
               "C=true;"
               "u=i+R*(T-.01f);"
               "float o=1+-sign(R[W])*l[W]/2.f;"
               "\n#ifdef CLASSIC\n"
               "float g=T/RD*(255-(W+2)%3*50)/255;"
               "e=mix(D,P,g);"
               "\n#else\n"
               "e=D*mix(a,s,o);"
               "\n#endif\n"
               "return e;"
             "}"
         "}"
       "if(y.y<y.x)"
         "{"
           "if(y.y<y.z)"
             "m.y+=d.y,T=y.y,y.y+=e.y,W=1;"
           "else"
             " m.z+=d.z,T=y.z,y.z+=e.z,W=2;"
         "}"
       "else"
         " if(y.x<y.z)"
           "m.x+=d.x,T=y.x,y.x+=e.x,W=0;"
         "else"
           " m.z+=d.z,T=y.z,y.z+=e.z,W=2;"
     "}"
   "C=false;"
   "\n#ifdef CLASSIC\n"
   "e=vec3(0);"
   "\n#else\n"
   "e=P;"
   "\n#endif\n"
   "return e;"
 "}"
 "vec3 i(in vec2 v)"
 "{"
   "const vec2 y=(v-.5*S)/c.fD;"
   "const float T=c.cP+y.y*c.sP;"
   "vec3 i=normalize(vec3(y.x*c.cY+T*c.sY,y.y*c.cP-c.sP,T*c.cY-y.x*c.sY));"
   "const vec3 W=mix(k,s,.5*pow(clamp(dot(i,l),0,1)+.2,5));"
   "vec3 R;"
   "bool m;"
   "float P;"
   "vec3 e=f(c.P,i,RD,W,m,R,P);"
   "\n#ifndef CLASSIC\n"
   "if(m)"
     "{"
       "float D=(1-l.y)*.3;"
       "if(l.y<0)"
         "{"
           "float C=0;"
           "vec3 u=f(R,l,RD/2,W,m,R,C);"
           "if(m)"
             "D*=1+l.y*.3;"
         "}"
       "else"
         " D=(1-l.y)*.3;"
       "e=e*D;"
       "if(P>RD*.95)"
         "{"
           "float C=(P-RD*.95)/(RD*.05);"
           "e=mix(e,W,C);"
         "}"
     "}"
   "\n#endif\n"
   "return e;"
 "}"
 "void main()"
 "{"
   "ivec2 R=ivec2(gl_GlobalInvocationID.xy);"
   "vec4 v=vec4(i(R),1);"
   "imageStore(img_output,R,v);"
 "}";

const char *screen_frag =
 "#version 330 core\n"
 "in vec2 t;"
 "uniform sampler2D T;"
 "void main()"
 "{"
   "gl_FragColor=texture(T,t);"
 "}";

const char *screen_vert =
 "#version 330 core\n"
 "layout(location=0)in vec2 P;"
 "layout(location=2)in vec2 T;"
 "out vec2 t;"
 "void main()"
 "{"
   "vec4 e=vec4(P,1.F,1.F);"
   "gl_Position=e;"
   "t=T;"
 "}";

#endif // SHADER_CODE_H_
