/* File generated with Shader Minifier 1.1.6
 * http://www.ctrl-alt-test.fr
 */
#ifndef SHADER_CODE_H_
# define SHADER_CODE_H_

const char *raytrace_comp =
 "#version 430\n"
 "layout(local_size_x=16,local_size_y=16) in;"
 "layout(rgba32f,binding=0)writeonly uniform image2D img_output;"
 "layout(r8ui,binding=1)readonly uniform uimage3D blockData;\n"
 "#define WORLD_SIZE 512\n"
 "#define WORLD_HEIGHT 64\n"
 "#define TEXTURE_RES 16\n"
 "#define RENDER_DIST 80.0\n"
 "#define BLOCK_AIR 0\n"
 "uniform sampler2D textureAtlas;struct Camera{vec3 pos;float cosYaw;float cosPitch;float sinYaw;float sinPitch;vec2 frustumDiv;};"
 "uniform Camera cam;"
 "uniform vec2 screenSize;"
 "uniform vec3 lightDirection,ambColor,skyColor,sunColor;"
 "int t(ivec3 v)"
 "{"
   "return int(imageLoad(blockData,v).x);"
 "}"
 "bool f(ivec3 v)"
 "{"
   "const vec3 i=step(vec3(0,-2,0),v),S=step(vec3(WORLD_SIZE,WORLD_HEIGHT,WORLD_SIZE),v);"
   "return dot(i,i)*dot(S,S)==0;"
 "}\n"
 "#define AXIS_X 0\n"
 "#define AXIS_Y 1\n"
 "#define AXIS_Z 2\n"
 "vec3 f(in vec3 v,in vec3 i,in float S,in vec3 s,out bool r,out vec3 m,out float c)"
 "{"
   "ivec3 n=ivec3(v),T=ivec3(sign(i));"
   "vec3 A=abs(1/i),l=-fract(v)*T;"
   "l+=max(T,vec3(0));"
   "l*=A;"
   "int C=AXIS_X;"
   "c=0;"
   "while(c<=S)"
     "{"
       "if(!f(n))"
         "break;"
       "int y=t(n);"
       "if(y!=BLOCK_AIR)"
         "{"
           "m=v+i*c;"
           "int x=int(mod((m.x+m.z)*TEXTURE_RES,TEXTURE_RES)),b=int(mod(m.y*TEXTURE_RES,TEXTURE_RES)+TEXTURE_RES);"
           "if(C==AXIS_Y)"
             "{"
               "x=int(mod(m.x*TEXTURE_RES,TEXTURE_RES));"
               "b=int(mod(m.z*TEXTURE_RES,TEXTURE_RES));"
               "if(i.y<0.F)"
                 "b+=TEXTURE_RES*2;"
             "}"
           "vec3 z=vec3(texture(textureAtlas,vec2((x+y*TEXTURE_RES+.5)/float(TEXTURE_RES*16.),(b+.5)/float(TEXTURE_RES*3.))));"
           "if(dot(z,z)!=0)"
             "{"
               "r=true;"
               "m=v+i*(c-.01f);"
               "float R=1+-sign(i[C])*lightDirection[C]/2.f;"
               "\n#ifdef CLASSIC\n"
               "float W=c/RENDER_DIST*(255-(C+2)%3*50)/255;"
               "A=mix(z,s,W);"
               "\n#else\n"
               "A=z*mix(ambColor,sunColor,R);"
               "\n#endif\n"
               "return A;"
             "}"
         "}"
       "if(l.y<l.x)"
         "{"
           "if(l.y<l.z)"
             "n.y+=T.y,c=l.y,l.y+=A.y,C=AXIS_Y;"
           "else"
             " n.z+=T.z,c=l.z,l.z+=A.z,C=AXIS_Z;"
         "}"
       "else"
         " if(l.x<l.z)"
           "n.x+=T.x,c=l.x,l.x+=A.x,C=AXIS_X;"
         "else"
           " n.z+=T.z,c=l.z,l.z+=A.z,C=AXIS_Z;"
     "}"
   "r=false;"
   "\n#ifdef CLASSIC\n"
   "A=vec3(0);"
   "\n#else\n"
   "A=s;"
   "\n#endif\n"
   "return A;"
 "}"
 "vec3 v(in vec2 v)"
 "{"
   "const vec2 l=(v-.5*screenSize)/cam.frustumDiv;"
   "const float i=cam.cosPitch+l.y*cam.sinPitch;"
   "vec3 C=normalize(vec3(l.x*cam.cosYaw+i*cam.sinYaw,l.y*cam.cosPitch-cam.sinPitch,i*cam.cosYaw-l.x*cam.sinYaw));"
   "const vec3 s=mix(skyColor,sunColor,.5*pow(clamp(dot(C,lightDirection),0,1)+.2,5));"
   "vec3 c;"
   "bool S;"
   "float m;"
   "vec3 A=f(cam.pos,C,RENDER_DIST,s,S,c,m);"
   "\n#ifndef CLASSIC\n"
   "if(S)"
     "{"
       "float T=(1-lightDirection.y)*.3;"
       "if(lightDirection.y<0)"
         "{"
           "float R=0;"
           "vec3 n=f(c,lightDirection,RENDER_DIST/2,s,S,c,R);"
           "if(S)"
             "T*=1+lightDirection.y*.3;"
         "}"
       "else"
         " T=(1-lightDirection.y)*.3;"
       "A=A*T;"
       "if(m>RENDER_DIST*.95)"
         "{"
           "float R=(m-RENDER_DIST*.95)/(RENDER_DIST*.05);"
           "A=mix(A,s,R);"
         "}"
     "}"
   "\n#endif\n"
   "return A;"
 "}"
 "void main()"
 "{"
   "ivec2 i=ivec2(gl_GlobalInvocationID.xy);"
   "vec4 C=vec4(v(i),1);"
   "imageStore(img_output,i,C);"
 "}";

const char *screen_frag =
 "#version 330 core\n"
 "in vec2 t;"
 "uniform sampler2D T;"
 "void main()"
 "{"
   "gl_FragColor=texture(T,t);"
 "}";

const char *screen_vert =
 "#version 330 core\n"
 "layout(location=0)in vec2 P;"
 "layout(location=2)in vec2 T;"
 "out vec2 t;"
 "void main()"
 "{"
   "vec4 A=vec4(P,1.F,1.F);"
   "gl_Position=A;"
   "t=T;"
 "}";

#endif // SHADER_CODE_H_
